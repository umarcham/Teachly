<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Video Call</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #e91e63;
            /* Updated to Pink theme */
            --danger-color: #ef4444;
            --glass-bg: rgba(255, 255, 255, 0.8);
            /* Light glass */
            --glass-border: rgba(0, 0, 0, 0.1);
            --text-color: #344767;
            /* Dark text */
            --bg-color: #f0f2f5;
        }

        body {
            font-family: 'Inter', sans-serif;
            /* Changed to Inter */
            background: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Full Screen Avatar */
        #avatar-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #fff;
            /* Light background */
        }

        #avatarVideo {
            width: 100%;
            height: 100%;
            object-fit: contain;
            position: relative;
            z-index: 2;
            /* Ensure full video is visible */
        }

        #avatar-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            filter: blur(30px) opacity(0.5);
            /* Lighter blur */
            z-index: 1;
            transition: background-image 0.5s ease;
        }

        /* PIP User Video */
        #user-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            overflow: hidden;
            z-index: 10;
            border: 4px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            background: #fff;
        }

        #user-container:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.5);
        }

        #userVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            /* Mirror effect */
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
            /* Let clicks pass through to video if needed, but controls will re-enable */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Top Bar */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: auto;
        }

        .status-badge {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background-color: #10b981;
            border-radius: 50%;
            box-shadow: 0 0 8px #10b981;
        }

        .status-dot.offline {
            background-color: #ef4444;
            box-shadow: 0 0 8px #ef4444;
        }

        /* Transcript Overlay */
        #transcript-container {
            text-align: center;
            margin-bottom: 20px;
            pointer-events: auto;
            width: 100%;
            display: flex;
            justify-content: center;
        }

        #transcript {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 16px 32px;
            border-radius: 16px;
            max-width: 80%;
            font-size: 18px;
            line-height: 1.6;
            color: #344767;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s;
            transition: opacity 0.3s;
        }

        /* Controls Bar */
        .controls-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            pointer-events: auto;
        }

        .control-btn {
            background: #fff;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            color: #344767;
            padding: 16px 32px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .control-btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn-primary:hover:not(:disabled) {
            background: #d81b60;
            color: white;
        }

        .btn-danger {
            background: var(--danger-color);
            border-color: var(--danger-color);
        }

        .btn-danger:hover:not(:disabled) {
            background: #dc2626;
        }

        /* Presenter Selection Modal */
        #selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }

        #selection-modal.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .modal-content {
            text-align: center;
            max-width: 1000px;
            width: 90%;
            max-height: 85vh;
            /* Reduced height to ensure fit on smaller screens */
            display: flex;
            flex-direction: column;
            background: #fff;
            /* Slightly more opaque */
            padding: 40px;
            /* Reduced padding */
            border-radius: 24px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.1);
        }

        .modal-title {
            font-size: 32px;
            margin-bottom: 20px;
            font-weight: 300;
            letter-spacing: 1px;
            flex-shrink: 0;
        }

        #presenter-grid {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            overflow-y: auto;
            padding: 10px;
            flex: 1;
            min-height: 0;
        }

        /* Custom scrollbar for grid */
        #presenter-grid::-webkit-scrollbar {
            width: 8px;
        }

        #presenter-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        #presenter-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .presenter-card {
            width: 120px;
            height: 120px;
            border-radius: 16px;
            overflow: hidden;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
            position: relative;
            flex-shrink: 0;
        }

        .presenter-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .presenter-card:hover {
            transform: scale(1.1);
        }

        .presenter-card.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.5);
            transform: scale(1.1);
        }

        .start-call-btn-large {
            margin-top: 30px;
            padding: 16px 48px;
            font-size: 20px;
            font-size: 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
            flex-shrink: 0;
        }

        .start-call-btn-large:hover {
            transform: scale(1.05);
        }

        /* Debug Log (Hidden by default) */
        #debug-log {
            display: none;
            position: fixed;
            top: 60px;
            left: 20px;
            width: 300px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            padding: 10px;
            border-radius: 8px;
            overflow-y: auto;
            z-index: 50;
            pointer-events: auto;
        }

        /* Form Inputs */
        .form-group {
            margin-bottom: 20px;
            text-align: left;
            width: 100%;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #344767;
            font-size: 14px;
        }

        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d2d6da;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            transition: all 0.2s;
            box-sizing: border-box;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(233, 30, 99, 0.1);
        }
    </style>
</head>

<body>

    <!-- Full Screen Avatar -->
    <div id="avatar-container">
        <div id="avatar-background"></div>
        <video id="avatarVideo" autoplay playsinline></video>
    </div>

    <!-- PIP User Video -->
    <div id="user-container">
        <video id="userVideo" autoplay playsinline muted></video>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div class="top-bar">
            <div class="status-badge">
                <div class="status-dot" id="connection-dot"></div>
                <span id="connection-status">Ready</span>
            </div>
            <button onclick="toggleDebug()"
                style="background:none; border:none; color:white; opacity:0.3; cursor:pointer;">üêû</button>
        </div>

        <div id="transcript-container">
            <div id="transcript">Select an avatar to begin</div>
        </div>

        <div class="controls-bar">
            <!-- Main controls are in the modal initially, but we keep these for in-call control -->
            <button id="stopBtn" class="control-btn btn-danger" disabled>
                End Call
            </button>
            <button id="testBtn" class="control-btn" disabled>
                Test Audio
            </button>
        </div>
    </div>

    <!-- Presenter Selection Modal -->
    <div id="selection-modal">
        <div class="modal-content">
            <h1 class="modal-title" style="color: #344767; font-weight: 700;">Start Learning Session</h1>

            <div class="form-group">
                <label class="form-label">Your Name</label>
                <input type="text" id="userName" class="form-control" placeholder="e.g. John Doe">
            </div>
            <div class="form-group">
                <label class="form-label">Topic to Learn</label>
                <input type="text" id="topic" class="form-control"
                    placeholder="e.g. Quantum Physics, History of Rome...">
            </div>
            <div class="form-group">
                <label class="form-label">Voice</label>
                <select id="voiceSelect" class="form-control">
                    <option value="" disabled selected>Loading voices...</option>
                </select>
            </div>

            <h3 style="margin: 20px 0 10px; color: #344767; font-size: 18px;">Choose Your AI Tutor</h3>
            <div id="presenter-grid" style="height: 200px; min-height: 200px;">
                <!-- Presenters injected here -->
            </div>
            <button id="startBtn" class="start-call-btn-large">Start Session</button>
        </div>
    </div>

    <!-- Debug Log -->
    <div id="debug-log"></div>

    <script>
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const testBtn = document.getElementById('testBtn');
        const userVideo = document.getElementById('userVideo');
        const avatarVideo = document.getElementById('avatarVideo');
        const transcriptDiv = document.getElementById('transcript');
        const presenterGrid = document.getElementById('presenter-grid');
        const debugLog = document.getElementById('debug-log');
        const selectionModal = document.getElementById('selection-modal');
        const connectionStatus = document.getElementById('connection-status');
        const connectionDot = document.getElementById('connection-dot');
        const userNameInput = document.getElementById('userName');
        const topicInput = document.getElementById('topic');
        const voiceSelect = document.getElementById('voiceSelect');

        const avatarBackground = document.getElementById('avatar-background');

        function log(msg) {
            console.log(msg);
            const div = document.createElement('div');
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            debugLog.appendChild(div);
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        function toggleDebug() {
            debugLog.style.display = debugLog.style.display === 'none' ? 'block' : 'none';
        }

        function updateStatus(status, isError = false) {
            connectionStatus.textContent = status;
            connectionDot.className = isError ? 'status-dot offline' : 'status-dot';
        }

        let peerConnection;
        let streamId;
        let sessionId;
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let selectedPresenterUrl = null;

        // Load Presenters
        async function loadPresenters() {
            const grid = document.getElementById('presenter-grid');
            // Keep the upload card
            const uploadCardHTML = `
                <div class="presenter-card" onclick="document.getElementById('avatarUpload').click()">
                    <div class="presenter-thumb" style="display: flex; align-items: center; justify-content: center; background: #f8f9fa; border: 2px dashed #cbd5e1;">
                        <div style="text-align: center; color: #64748b;">
                            <i class="fas fa-plus" style="font-size: 24px; margin-bottom: 8px;"></i>
                            <div style="font-size: 12px; font-weight: 600;">Upload Custom</div>
                        </div>
                    </div>
                </div>
                <input type="file" id="avatarUpload" accept="image/*" style="display: none;" onchange="uploadAvatar(this)">
            `;

            grid.innerHTML = uploadCardHTML;

            try {
                // 1. Static defaults
                const defaults = [
                    { image_url: "https://d-id-public-bucket.s3.us-west-2.amazonaws.com/alice.jpg", name: "Alice" },
                    { image_url: "https://create-images-results.d-id.com/DefaultPresenters/Emma_f/image.jpeg", name: "Emma" },
                    { image_url: "https://create-images-results.d-id.com/DefaultPresenters/Jack_m/image.jpeg", name: "Jack" }
                ];

                // 2. Fetch User Avatars
                let userAvatars = [];
                try {
                    const res = await fetch('/api/user-avatars');
                    const data = await res.json();
                    if (data.ok && data.avatars) {
                        userAvatars = data.avatars;
                    }
                } catch (e) {
                    console.error("Failed to fetch user avatars", e);
                }

                // Combine: User avatars first
                const allPresenters = [...userAvatars, ...defaults];

                allPresenters.forEach((p, index) => {
                    if (!p.image_url) return;

                    const div = document.createElement('div');
                    div.className = 'presenter-card';
                    div.onclick = () => selectPresenter(div, p.image_url);
                    div.innerHTML = `<img src="${p.image_url}" class="presenter-thumb" title="${p.name || 'Avatar'}">`;
                    grid.appendChild(div);

                    // Select the first one by default (likely the user's avatar)
                    if (index === 0) selectPresenter(div, p.image_url);
                });
            } catch (e) {
                console.error(e);
            }
        }

        function selectPresenter(el, url) {
            document.querySelectorAll('.presenter-card').forEach(t => t.classList.remove('selected'));
            el.classList.add('selected');
            selectedPresenterUrl = url;

            // Set background preview
            avatarBackground.style.backgroundImage = `url(${url})`;

            startBtn.disabled = false; // Enable start button once selected
            /* startBtn.disabled = false; */ // Keep enabled, validation on click
            log("Selected avatar: " + url);
        }

        // Load Voices
        async function loadVoices() {
            try {
                const res = await fetch('/api/voices');
                const data = await res.json();
                if (data.ok && data.voices) {
                    voiceSelect.innerHTML = ''; // Clear loading
                    data.voices.forEach(v => {
                        const opt = document.createElement('option');
                        opt.value = v.voice_id;
                        opt.textContent = `${v.name} (${v.gender})`;
                        // Select Jenny by default
                        if (v.voice_id === 'en-US-JennyNeural') opt.selected = true;
                        voiceSelect.appendChild(opt);
                    });
                }
            } catch (e) {
                log("Failed to load voices: " + e.message);
                voiceSelect.innerHTML = '<option value="en-US-JennyNeural">Jenny (US) - Default</option>';
            }
        }

        loadPresenters();
        loadVoices();

        // D-ID WebRTC Config
        const RTCPeerConnection = (window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection).bind(window);

        startBtn.onclick = async () => {
            if (!selectedPresenterUrl) {
                alert("Please select an avatar first.");
                return;
            }
            const name = userNameInput.value.trim();
            const topic = topicInput.value.trim();
            const voiceId = voiceSelect.value;

            if (!name || !topic) {
                alert("Please enter your name and a topic.");
                return;
            }

            // Hide modal
            selectionModal.classList.add('hidden');

            stopBtn.disabled = false;
            testBtn.disabled = false;
            transcriptDiv.innerText = "Initializing session...";
            updateStatus("Connecting...");
            log("Starting call...");

            try {
                // 0. Start Backend Session
                log("Initializing backend session...");
                // Generate a session ID (simple random string for now, or use D-ID's later)
                // Actually, we need a session ID for the backend *before* we get one from D-ID? 
                // No, D-ID gives us a session ID. But we want to store context *now*.
                // Let's generate a temporary ID or use the one from D-ID. 
                // Better: Let's wait for D-ID stream creation to get a session ID, 
                // OR generate one ourselves. D-ID requires its own session ID for streams.
                // Let's use a placeholder ID for the *chat* session, or update it later.
                // Actually, the backend expects `session_id` to key the chat. 
                // Let's generate a UUID for our internal session, and pass that to process-audio.
                // But `process-audio` receives `session_id` from the frontend, which usually comes from D-ID.
                // Let's stick to D-ID's session ID if possible.
                // BUT, we want to start the chat *before* the stream to set the system prompt?
                // No, we can start it *after* we get the ID.

                // 1. Get User Media
                log("Requesting user media...");
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                userVideo.srcObject = stream;
                log("User media acquired");

                // 2. Create D-ID Stream
                log("Creating D-ID stream...");
                const createRes = await fetch('/create-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source_url: selectedPresenterUrl })
                });
                const createData = await createRes.json();

                if (createData.error) throw new Error(createData.error);

                streamId = createData.id;
                sessionId = createData.session_id;
                const offer = createData.offer;
                const iceServers = createData.ice_servers;
                log(`Stream created. ID: ${streamId}, Session: ${sessionId}`);

                // 2.5 Initialize Backend Chat Session
                log("Starting AI Session...");
                await fetch('/start-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        user_name: name,
                        topic: topic,
                        voice_id: voiceId
                    })
                });
                transcriptDiv.innerText = `Topic: ${topic}. Connecting...`;

                // 3. Setup WebRTC
                log("Setting up WebRTC PeerConnection...");
                peerConnection = new RTCPeerConnection({ iceServers });

                peerConnection.oniceconnectionstatechange = () => {
                    log("ICE State: " + peerConnection.iceConnectionState);
                    updateStatus(peerConnection.iceConnectionState);
                    if (peerConnection.iceConnectionState === 'connected') {
                        transcriptDiv.innerText = "Connected! Speak naturally.";
                    }
                };

                peerConnection.ontrack = (event) => {
                    log("Track received: " + event.streams[0].id);
                    if (event.streams && event.streams[0]) {
                        if (avatarVideo.srcObject !== event.streams[0]) {
                            avatarVideo.srcObject = event.streams[0];
                            avatarVideo.muted = false;
                            avatarVideo.play().catch(e => {
                                log("Autoplay failed, trying muted: " + e);
                                avatarVideo.muted = true;
                                avatarVideo.play();
                            });
                        }
                    }
                };

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        fetch('/submit-network-info', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                candidate: event.candidate,
                                session_id: sessionId,
                                stream_id: streamId
                            })
                        }).catch(e => log("ICE Fetch Error: " + e));
                    }
                };

                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                await fetch('/submit-network-info', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        answer: answer,
                        session_id: sessionId,
                        stream_id: streamId
                    })
                });

                startAudioRecording(stream);

            } catch (e) {
                log("Error: " + e.message);
                alert("Error starting call: " + e.message);
                resetUI();
            }
        };

        stopBtn.onclick = async () => {
            log("Stopping call...");
            if (streamId && sessionId) {
                await fetch('/close-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId, stream_id: streamId })
                });
            }
            if (peerConnection) peerConnection.close();
            if (userVideo.srcObject) {
                userVideo.srcObject.getTracks().forEach(track => track.stop());
            }
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            resetUI();
        };

        testBtn.onclick = async () => {
            if (!sessionId || !streamId) return;
            log("Testing: Sending 'Hello'...");
            try {
                await fetch('/test-audio', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        stream_id: streamId,
                        text: "Hello! I am working correctly."
                    })
                });
            } catch (e) {
                log("Test error: " + e.message);
            }
        };

        function resetUI() {
            selectionModal.classList.remove('hidden');
            stopBtn.disabled = true;
            testBtn.disabled = true;
            userVideo.srcObject = null;
            avatarVideo.srcObject = null;
            transcriptDiv.innerText = "Call ended.";
            updateStatus("Ready");
            isRecording = false;
            log("UI Reset");
        }

        let isAvatarSpeaking = false;
        let isProcessing = false;
        let audioContext;
        let analyser;
        let microphone;
        let javascriptNode;
        let speechDetected = false;
        let avatarSpeakingTimeout;

        function startAudioRecording(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 512;
            analyser.smoothingTimeConstant = 0.1;
            microphone = audioContext.createMediaStreamSource(stream);
            javascriptNode = audioContext.createScriptProcessor(1024, 1, 1);

            microphone.connect(analyser);
            analyser.connect(javascriptNode);
            javascriptNode.connect(audioContext.destination);

            javascriptNode.onaudioprocess = function () {
                var array = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(array);
                var values = 0;
                var length = array.length;
                for (var i = 0; i < length; i++) {
                    values += array[i];
                }
                var average = values / length;

                if (average > 20) {
                    speechDetected = true;

                    // INTERRUPTION LOGIC
                    if (isAvatarSpeaking) {
                        log("Interruption detected! Muting avatar.");
                        avatarVideo.muted = true;
                        isAvatarSpeaking = false;
                        if (avatarSpeakingTimeout) {
                            clearTimeout(avatarSpeakingTimeout);
                            avatarSpeakingTimeout = null;
                        }
                        transcriptDiv.innerText = "Interruption detected. Listening...";
                    }
                }
            }

            const audioStream = new MediaStream(stream.getAudioTracks());
            mediaRecorder = new MediaRecorder(audioStream, { mimeType: 'audio/webm' });

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0 && !isProcessing) {
                    audioChunks.push(e.data);
                }
            };

            mediaRecorder.onstop = async () => {
                if (!isRecording) return;

                if (isProcessing) {
                    audioChunks = [];
                    speechDetected = false;
                    if (isRecording) mediaRecorder.start();
                    return;
                }

                if (!speechDetected) {
                    audioChunks = [];
                    if (isRecording) mediaRecorder.start();
                    return;
                }

                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                audioChunks = [];
                speechDetected = false;

                if (audioBlob.size > 0) {
                    processAudio(audioBlob);
                }

                if (isRecording) mediaRecorder.start();
            };

            isRecording = true;
            mediaRecorder.start();

            setInterval(() => {
                if (isRecording && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
            }, 3000);
        }

        async function processAudio(blob) {
            isProcessing = true;
            transcriptDiv.innerText = "Processing...";

            const formData = new FormData();
            formData.append('audio', blob);
            formData.append('session_id', sessionId);
            formData.append('stream_id', streamId);

            try {
                const res = await fetch('/process-audio', {
                    method: 'POST',
                    body: formData
                });
                const data = await res.json();

                if (data.transcription) {
                    transcriptDiv.innerText = "You: " + data.transcription;
                } else {
                    transcriptDiv.innerText = "Listening...";
                }

                if (data.reply) {
                    console.log("AI Reply:", data.reply);
                    isAvatarSpeaking = true;
                    transcriptDiv.innerText = "Avatar speaking...";

                    avatarVideo.muted = false;

                    const duration = Math.max(4000, data.reply.length * 100 + 2000);

                    if (avatarSpeakingTimeout) clearTimeout(avatarSpeakingTimeout);

                    avatarSpeakingTimeout = setTimeout(() => {
                        isAvatarSpeaking = false;
                        transcriptDiv.innerText = "Listening...";
                        avatarSpeakingTimeout = null;
                    }, duration);
                }
            } catch (e) {
                console.error("Audio processing error", e);
                transcriptDiv.innerText = "Error processing audio";
            } finally {
                isProcessing = false;
                if (!isAvatarSpeaking) transcriptDiv.innerText = "Listening...";
            }
        }

    </script>
</body>

</html>